---
title: 架构概述
description: driver-box的核心架构设计和实现原理
sidebar:
  order: 1
---

# 架构概述

driver-box 是一款基于 Go 语言开发的轻量级物联网边缘计算平台,采用**微内核 + 插件**的架构设计,专注于解决**设备数据接入、协议适配和数据输出**三大核心问题。

## 架构总览

driver-box 采用三层分层架构,各层职责明确、相互解耦:

```mermaid
flowchart BT
    subgraph Export["数据输出层"]
        E1[Gateway Export<br/>WebSocket实时推送]
        E2[Mirror Export<br/>设备虚拟化]
        E3[LinkEdge Export<br/>场景联动]
        E4[History Export<br/>历史数据存储]
    end

    subgraph Core["核心平台层"]
        C1[配置服务<br/>设备模型管理]
        C2[设备影子<br/>状态缓存与同步]
        C3[事件服务<br/>松耦合通信]
        C4[资源库<br/>Lua脚本驱动]
    end

    subgraph Plugin["协议接入层"]
        P1[Modbus Plugin]
        P2[MQTT Plugin]
        P3[HTTP Plugin]
        P4[TCP Plugin]
    end

    P1 --> C1
    P2 --> C1
    P3 --> C1
    P4 --> C1

    C1 --> C2
    C2 --> C3
    C3 --> E1
    C3 --> E2
    C3 --> E3
    C3 --> E4
```

**三层架构职责**:

| 层次 | 职责 | 关键组件 |
|------|------|---------|
| **协议接入层 (Plugin)** | 负责与物理设备通信,实现各种工业协议的适配 | Modbus、MQTT、HTTP、TCP 等协议插件 |
| **核心平台层 (Core)** | 设备配置管理、状态缓存、事件调度,是系统的核心中枢 | 配置服务、设备影子、事件服务、资源库 |
| **数据输出层 (Export)** | 将设备数据分发到不同的目标系统 | Gateway、Mirror、LinkEdge、History Export |

## 核心设计理念

driver-box 的架构设计遵循以下核心原则:

- **可扩展性**: 插件机制支持任意协议快速接入,无需修改核心代码
- **配置驱动**: 纯配置文件管理设备和模型,Lua 脚本实现灵活的数据转换
- **事件驱动**: 松耦合的事件系统实现数据在组件间的灵活流转
- **高内聚低耦合**: 各层职责清晰,接口标准化,易于维护和扩展

## 设计模式

| 设计模式 | 应用场景 | 价值 |
|---------|---------|------|
| 插件模式 | 协议插件的可扩展性 | 支持热插拔、易于扩展、隔离性好 |
| 适配器模式 | 统一不同协议的数据格式 | 上层调用无需关心底层协议细节 |
| 观察者模式 | 事件通知机制 | 松耦合、易于扩展事件处理逻辑 |
| 策略模式 | 灵活的数据处理策略 | 支持Lua脚本自定义编解码逻辑 |
| 单例模式 | 全局唯一实例管理 | 资源管理集中、状态一致 |

## 启动流程

系统启动遵循严格的初始化顺序:

```mermaid
flowchart TD
    A[main.go 启动] --> B[1. 注册所有插件和Export]
    B --> C[2. 初始化Export模块]
    C --> D[3. 加载设备配置]
    D --> E[4. 启动设备影子]
    E --> F[5. 初始化插件并建立连接]
    F --> G[6. 触发DeviceAdded事件]
    G --> H[系统就绪]

    style A fill:#e1f5ff
    style H fill:#d4edda
```

### 启动详细流程

```mermaid
sequenceDiagram
    participant Main as main.go
    participant PM as 插件管理器
    participant EM as 导出管理器
    participant Core as 核心服务
    participant Cache as Core Cache
    participant Shadow as 设备影子
    Plugin->>PM: 注册所有协议插件<br/>(Modbus/MQTT/HTTP等)
    Export->>EM: 注册所有导出模块<br/>(Gateway/Mirror/LinkEdge等)
    Main->>EM: Init()
    Note over EM: 初始化所有导出模块
    Main->>Cache: InitCoreCache(plugins)
    Note over Cache: 加载 res/driver 配置<br/>验证配置合法性
    Main->>Shadow: initDeviceShadow()
    Note over Shadow: 创建设备影子实例
    Main->>PM: Initialize(config)
    Note over PM: 启动所有插件<br/>建立设备连接
    Main->>EM: TriggerEvents(DeviceAdded)
    Note over EM: 通知导出模块设备上线
    Main-->>X: 系统启动完成
```

**启动关键步骤**:

1. **插件注册** - 扫描并注册所有协议插件和导出模块
2. **Export 初始化** - 初始化所有导出模块,准备接收数据
3. **配置加载** - 加载 `res/driver` 目录下的配置文件,构建设备模型缓存
4. **影子启动** - 创建设备影子实例,初始化状态管理
5. **插件启动** - 调用各插件的 `Initialize()` 方法,建立设备连接
6. **事件触发** - 触发 `DeviceAdded` 事件,通知 Export 模块设备上线

## 核心组件

### 插件系统

插件系统是 driver-box 可扩展性的基石,通过标准化接口实现协议的无缝接入。

#### 插件生命周期

```mermaid
stateDiagram-v2
    [*] --> Registered: EnablePlugin()
    Registered --> Initializing: plugins.EnableAll()
    Initializing --> Ready: Initialize()完成
    Ready --> Active: 首次Connector调用
    Active --> Processing: 编码和发送数据
    Processing --> Active: 操作完成
    Active --> Destroying: Stop()调用
    Destroying --> [*]: Destroy()完成
```

#### 连接器工作流程

```mermaid
sequenceDiagram
    participant API as driverbox API
    participant Core as Core Layer
    participant Plugin as Plugin
    participant Connector as Connector
    participant Device as Physical Device

    API->>Core: ReadPoint(deviceId, pointName)
    Core->>Plugin: Connector(deviceId)
    Plugin-->>Core: 返回Connector实例
    Core->>Connector: Encode(ReadMode, pointData)
    Connector->>Connector: encodeRead()
    Connector-->>Core: 编码后的数据
    Core->>Connector: Send(data)
    Connector->>Device: 发送协议报文
    Device-->>Connector: 返回数据
    Connector-->>Core: 解析后的数据
    Core->>Plugin: Release()
    Plugin->>Plugin: 释放连接
```

#### 核心接口

```go
// 插件接口 - 协议插件必须实现
type Plugin interface {
    Initialize(c config.DeviceConfig)              // 使用配置初始化插件
    Connector(deviceId string) (Connector, error)   // 获取设备连接器
    Destroy() error                                 // 销毁插件并释放资源
}

// 连接器接口 - 设备通信的具体实现
type Connector interface {
    Encode(deviceId string, mode EncodeMode, values ...PointData) (interface{}, error)
    Send(data interface{}) error
    Release() error
}
```

**核心机制**:
- **插件注册**: 系统启动时,各协议插件通过 `EnablePlugin()` 注册到插件管理器
- **连接器获取**: 核心服务通过 `Connector(deviceId)` 获取指定设备的连接器
- **编解码处理**: `Encode()` 将点位数据编码为协议报文,`Send()` 发送至设备
- **资源释放**: `Release()` 释放连接器占用的网络资源

**内置协议插件**: Modbus (TCP/RTU)、MQTT (3.1.1/5.0)、HTTP Server、TCP Server、Gateway

### 核心缓存

核心缓存是系统的配置中心,管理所有设备、模型和连接配置。

**核心能力**:
- **模型管理**: `GetModel`、`AddModel`、`DeleteModel`
- **设备管理**: `GetDevice`、`AddOrUpdateDevice`、`DeleteDevice`
- **点位管理**: `GetPointByModel`、`GetPointByDevice`、`GetPoints`
- **连接管理**: `AddConnection`、`GetConnection`、`DeleteConnection`
- **持久化**: `Flush(pluginName)`、`FlushAll()`

**关键特性**:
- **配置热加载**: 监控 `res/driver` 目录变化,自动重新加载配置
- **自动持久化**: 配置变更后每 5 秒自动写入磁盘
- **线程安全**: 使用读写锁保护并发访问

### 设备影子

设备影子是设备状态的实时镜像,提供设备在线状态检测和点位值缓存。

**核心能力**:
- **点位值管理**: `SetDevicePoint`、`GetDevicePoint`、`GetDevicePoints`
- **写入指令管理**: `SetWritePointValue`、`GetWritePointValue`
- **状态管理**: `GetDeviceStatus`、`SetOnline`、`SetOffline`、`MayBeOffline`

**在线状态判定**:
1. **TTL 机制**: 超过配置的 TTL 时间未收到数据,判定为离线
2. **失败计数**: 60 秒内断开次数超过 3 次,判定为离线

**缓存机制**:
- **点位值缓存**: 存储设备所有点位的最新值,支持快速查询
- **写入值缓存**: 记录下发的控制指令,用于写后读验证
- **事件触发**: 状态变化时触发 `ShadowOnline`/`ShadowOffline` 事件

### Export 系统

Export 系统负责将设备数据分发到不同的目标系统。

#### 数据处理流程

```mermaid
flowchart LR
    A[设备数据变化] --> B[core.SendSinglePoint]
    B --> C[shadow.SetPointValue<br/>更新影子]
    C --> D{上报模式?}
    D -->|实时上报| E[TriggerEvents]
    D -->|变化上报| F{值是否变化?}
    F -->|变化| E
    F -->|未变化| G[跳过导出]
    E --> H[遍历所有Export模块]
    H --> I[export.IsReady?]
    I -->|就绪| J[export.ExportTo]
    I -->|未就绪| K[跳过此Export]
    J --> L[数据处理与转换]
    L --> M[发送到外部系统]
    M --> N{发送成功?}
    N -->|成功| O[记录成功指标]
    N -->|失败| P[记录错误并重试]
```

#### 核心接口

```go
type Export interface {
    Init() error                                                      // 初始化模块
    ExportTo(deviceData plugin.DeviceData)                            // 导出数据
    OnEvent(eventCode event.EventCode, key string, value interface{}) error  // 事件回调
    IsReady() bool                                                    // 就绪检查
    Destroy() error                                                   // 销毁模块
}
```

**内置 Export 模块**:
- **Gateway Export**: WebSocket 实时推送,支持前端实时监控
- **Mirror Export**: 创建镜像设备,实现设备虚拟化和协议转换
- **LinkEdge Export**: 场景联动引擎,支持自动化控制
- **History Export**: 历史数据存储,支持数据分析和报表

**上报模式**:
- **周期上报** (`period`): 按固定周期上报所有点位
- **变化上报** (`change`): 仅上报值发生变化的点位
- **实时上报** (`realtime`): 每次采集都上报

**点位缓存过滤**:

```go
// 变化上报模式: 比较影子中的缓存值
if point.ReportMode() == config.ReportMode_Change {
    shadowValue, _ := Shadow().GetDevicePoint(deviceId, pointName)
    if shadowValue == newValue {
        continue  // 值未变化,跳过导出
    }
}
```

### 资源库系统

资源库系统提供设备模型、设备驱动、协议驱动和镜像模板的统一管理。

| 资源库 | 配置路径 | 功能 |
|--------|---------|------|
| Model | `res/library/model/` | 设备模型定义和验证 |
| Driver | `res/library/driver/` | Lua 脚本驱动,实现灵活的数据转换 |
| Protocol | `res/library/protocol/` | 协议层驱动定义 |
| Mirror | `res/library/mirror_tpl/` | 镜像模板配置 |

**Lua 脚本驱动示例**:

```lua
-- 编码: Write 操作
function encode(deviceId, mode, points)
    local result = {}
    for _, point in ipairs(points) do
        result[#result + 1] = {
            name = point.name,
            value = point.value * point.scale
        }
    end
    return result
end

-- 解码: Read 操作
function decode(deviceId, points)
    local result = {}
    local events = {}
    for _, point in ipairs(points) do
        result[#result + 1] = {
            name = point.name,
            value = point.value / point.scale
        }
        -- 事件生成
        if point.value > threshold then
            events[#events + 1] = { code = "alarm", value = point.value }
        end
    end
    return result, events
end
```

### 事件系统

事件系统实现松耦合的组件间通信,支持事件订阅和广播。

**核心事件类型**:
- `ServiceStatus`: 服务状态变更
- `DeviceAdded` / `DeviceDeleted`: 设备添加/删除
- `ShadowOnline` / `ShadowOffline`: 设备上线/离线
- `DoExport` / `Exporting`: 导出操作

**事件机制**:
- 事件触发: `TriggerEvents(eventCode, key, value)` 广播事件到所有订阅者
- 事件订阅: 导出模块通过 `OnEvent()` 方法订阅感兴趣的事件
- 异步处理: 事件回调异步执行,避免阻塞主流程

## 数据流转

### 读操作流程

```mermaid
flowchart LR
    A[API请求<br/>driverbox.ReadPoint] --> B[core.SendSinglePoint<br/>单点读取]
    B --> C[deviceDriverProcess<br/>设备驱动层处理]
    C --> D[cache.GetPointByDevice<br/>获取点位配置]
    D --> E[getConnector<br/>获取设备连接器]
    E --> F[conn.Encode<br/>协议层编码]
    F --> G[conn.Send<br/>发送指令到设备]
    G --> H[数据解析与处理]
    H --> I[shadow.SetPointValue<br/>更新影子]
    I --> J[TriggerEvents<br/>触发Export事件]
    J --> K[ExportTo<br/>分发到Export模块]
```

### 写操作流程

```mermaid
flowchart LR
    A[API请求<br/>driverbox.WritePoint] --> B[shadow.SetWritePoint<br/>存储写入值]
    B --> C[deviceDriverProcess<br/>设备驱动层处理]
    C --> D[getConnector<br/>获取设备连接器]
    D --> E[conn.Encode<br/>协议层编码]
    E --> F[conn.Send<br/>发送指令到设备]
    F --> G{发送成功?}
    G -->|成功| H[tryReadNewValues<br/>立即读回验证]
    G -->|失败| I[shadow.MayBeOffline<br/>标记可能离线]
    H --> J[更新影子]
    J --> K[触发Export事件]
```

### 事件驱动流程

```mermaid
graph TB
    A[设备状态变化/数据上报] --> B[触发事件]
    B --> C{事件类型}
    C -->|DeviceAdded| D[通知 Export 模块<br/>创建镜像设备]
    C -->|ShadowOffline| E[通知 Export 模块<br/>暂停数据推送]
    C -->|DoExport| F[执行数据导出<br/>触发所有 Export 模块]
    C -->|ShadowOnline| G[通知 Export 模块<br/>恢复数据推送]
```

## 配置系统

### 配置目录结构

```
res/
├── driver/                          # 协议插件配置
│   ├── modbus/
│   │   └── config.json
│   ├── mqtt/
│   │   └── config.json
│   └── ...
└── library/                         # 资源库
    ├── model/                       # 设备模型
    │   └── sensor_model.json
    ├── driver/                      # 设备驱动 (Lua)
    │   ├── encode.lua
    │   └── decode.lua
    ├── protocol/                    # 协议驱动
    └── mirror_tpl/                  # 镜像模板
```

### 设备配置示例

```json
{
  "pluginName": "modbus",
  "deviceModels": [
    {
      "name": "sensor",
      "modelId": "sensor_001",
      "description": "温湿度传感器",
      "devicePoints": [
        {
          "name": "temperature",
          "description": "温度",
          "valueType": "float",
          "readWrite": "r",
          "reportMode": "change",
          "scale": 0.1,
          "address": 40001,
          "registerType": "holding"
        }
      ],
      "devices": [
        {
          "id": "sensor_001",
          "description": "1号传感器",
          "connectionKey": "conn_1",
          "driverKey": "sensor_driver",
          "ttl": "60s"
        }
      ]
    }
  ],
  "connections": {
    "conn_1": {
      "host": "192.168.1.100",
      "port": 502,
      "mode": "tcp"
    }
  }
}
```

### 环境变量

| 变量名 | 说明 | 默认值 |
|-------|------|--------|
| `DRIVERBOX_RESOURCE_PATH` | 资源目录路径 | `./res` |
| `DRIVERBOX_HTTP_LISTEN` | HTTP 服务监听地址 | `:8080` |
| `DRIVERBOX_LOG_PATH` | 日志目录路径 | `./logs` |
| `LOG_LEVEL` | 日志级别 | `info` |

## 关键特性

- **高性能**: 核心内存占用 50-128MB,单点数据处理延迟 < 10ms,支持数千设备同时接入
- **可靠性**: 自动重连机制、TTL + 失败计数双重离线检测、数据缓存保证一致性、插件异常隔离
- **易用性**: 纯 JSON 配置文件、Lua 脚本灵活扩展、配置热加载无需重启、RESTful API + WebSocket 接口

